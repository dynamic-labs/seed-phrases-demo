import React, { useState, useEffect } from "react";

import { useEffectOnce } from "usehooks-ts";

import { entropyToMnemonic } from "bip39";

import {
  binaryToDecimal,
  entropyLengthToEntropyHex,
  wordCountToTotalBits,
  hexToBinary,
  wordsToBits,
  funFactsByWordCount,
  mnemonicToBits,
  calculateChecksum,
} from "./utils";

import ChecksumValidator from "./CheckSumValidation";
import { createHash } from "crypto";

const Generator = () => {
  type ValidWordCount = 12 | 15 | 18 | 21 | 24;

  const [funFact, setFunFact] = useState("");
  const [wordCount, setWordCount] = useState<ValidWordCount>(12);

  const [seedPhrase, setSeedPhrase] = useState("");
  const [entropyLength, setEntropyLength] = useState<number>(0);
  const [entropyHex, setEntropyHex] = useState<string>("");

  useEffectOnce(() => {
    const entropyLength = wordCountToTotalBits(wordCount);
    setEntropyLength(entropyLength);

    const newEntropyHex = entropyLengthToEntropyHex(entropyLength);
    setEntropyHex(newEntropyHex);

    const newFunFact = getFunFact(wordCount);
    setFunFact(newFunFact);
  });

  useEffect(() => {
    const entropyLength = wordCountToTotalBits(wordCount);
    setEntropyLength(entropyLength);

    const newEntropyHex = entropyLengthToEntropyHex(entropyLength);
    setEntropyHex(newEntropyHex);

    const newFunFact = getFunFact(wordCount);
    setFunFact(newFunFact);
  }, [wordCount]);

  /**
   * Generates a seed phrase and sets it in the component state.
   * Also sets the bits in the component state.
   * @returns A promise that resolves to the generated seed phrase.
   * @throws An error if there was an issue generating the seed phrase.
   */
  const generateSeedPhrase = async (): Promise<string> => {
    try {
      return await entropyToMnemonic(entropyHex);
    } catch (error) {
      console.error("Error generating seed phrase:", error);
      throw error;
    }
  };

  const handleWordCountChange = (
    setWordCount: React.Dispatch<React.SetStateAction<ValidWordCount>>,
    event: React.ChangeEvent<HTMLSelectElement>
  ) => {
    const selectedWordCount = parseInt(event.target.value, 10);
    if (![12, 15, 18, 21, 24].includes(selectedWordCount)) {
      console.error("Invalid word count selected");
      return;
    }
    setWordCount(selectedWordCount as ValidWordCount);
  };

  /**
   * Handles the click event for the generate seed phrase button.
   * Generates a seed phrase and sets it in the component state.
   */
  const handleGenerateClick = async () => {
    const phrase = await generateSeedPhrase();
    setSeedPhrase(phrase);
  };

  const getFunFact = (wordCount: ValidWordCount) => {
    return funFactsByWordCount[wordCount];
  };

  const getEntropyHash = (entropyHex: string): string => {
    const entropyBuffer = Buffer.from(entropyHex, "hex");

    // Hash the entropy buffer using SHA-256
    const hash = createHash("sha256").update(entropyBuffer).digest("hex");

    return hash;
  };

  return (
    <div className="generator-container">
      <h1>Seed Phrase Generator</h1>
      {seedPhrase === "" && (
        <div className="setup">
          <div className="dropdown-container">
            <label htmlFor="wordCount" className="word-count-label">
              Word Count:
            </label>
            <select
              id="wordCount"
              value={wordCount}
              onChange={(event) => handleWordCountChange(setWordCount, event)}
            >
              <option value="12">12</option>
              <option value="15">15</option>
              <option value="18">18</option>
              <option value="21">21</option>
              <option value="24">24</option>
            </select>
          </div>
          <p>{funFact}</p>
          <div className="divider"></div>
          <div className="entropy-container">
            <h2>Entropy Visualization</h2>
            <p>
              Entropy is a large random number typically generated by a
              cryptographically secure random number generator.
            </p>
            <h3>Length</h3>
            <p className="entropy-length">{entropyLength} bits</p>
            <p>
              Each word in the mnemonic phrase represents 11 bits of entropy.
              However, out of the total bits, the last portion is reserved for
              checksum bits. In BIP-39, the checksum length is determined by
              dividing the total length by 32 and rounding to the nearest whole
              number. For a word count of {wordCount}, this results in a total
              of {wordCount * 11} bits and {Math.round((wordCount * 11) / 32)}{" "}
              bits for the checksum which you subtract from the total to get the
              actual entropy length.
            </p>
            <h3>Hex</h3>
            <p className="entropy-hex">{entropyHex}</p>
            <p>
              Hexadecimal uses 16 different digits to represent values from 0 to
              15. These digits are: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E,
              F. In hexadecimal, the equivalent value of binary numbers can be
              expressed using fewer digits. Each hexadecimal digit corresponds
              to a group of four binary digits (bits), which is also known as a
              "nibble." A nibble is only capable of representing values from 0
              to 15.
            </p>
            <h3>Bits</h3>
            <p className="entropy-bits">{hexToBinary(entropyHex)}</p>
            <h3>Decimal</h3>
            <p className="entropy-decimal">
              {binaryToDecimal(hexToBinary(entropyHex))}
            </p>
            <h3>Hash of entropy hex</h3>
            <p className="entropy-hash">{getEntropyHash(entropyHex)}</p>
            <p>
              Hash functions are deterministic, which means that for the same
              input, they produce the same output every time. This property
              ensures that the same entropy will always produce the same
              checksum. Determinism is crucial for wallet backup and recovery
              scenarios where you want to ensure consistency in generating keys
              from the same entropy.
            </p>
          </div>
          <div className="divider"></div>
          <div>
            <p className="checksum-container">
              Checksum: {calculateChecksum(entropyHex)}
            </p>
            <p>
              {" "}
              In BIP-39, for every 32 bits of entropy, 1 bit of the hash is used
              as a checksum
            </p>
          </div>
          <div>
            <button onClick={handleGenerateClick}>Generate Seed Phrase</button>
          </div>
        </div>
      )}

      {seedPhrase !== "" && (
        <div result-container>
          <div className="phrase">
            <h3>Full Phrase</h3>
            <p>{seedPhrase}</p>
          </div>
          <div className="divider"></div>
          <div className="mapping">
            <h3>Word to bit mapping</h3>
            <div className="seed-phrase-container">
              {seedPhrase.split(" ").map((word, i) => (
                <div key={i} className="word-bit-pair">
                  <div className="word">{word}</div>
                  <div className="bits">
                    {wordsToBits(seedPhrase.split(" "))[i]}
                  </div>
                </div>
              ))}
            </div>
          </div>
          <div className="divider"></div>
          <div className="bits-visualization">
            <h3>Total bits (including checksum)</h3>
            <p>{mnemonicToBits(seedPhrase)}</p>
          </div>
          <div>
            <ChecksumValidator mnemonic={seedPhrase} />
          </div>
          <div className="new-phrase">
            <button onClick={() => setSeedPhrase("")}>
              Generate New Phrase
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default Generator;
